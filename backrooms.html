<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Backrooms 3D Maze</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      font-family: Arial, sans-serif;
      color: #fff;
    }

    #game {
      display: block;
      width: 100vw;
      height: 100vh;
      background: #000;
      cursor: crosshair;
    }

    #ui {
      position: fixed;
      left: 10px;
      top: 10px;
      z-index: 10;
      font-size: 14px;
      text-shadow: 0 0 4px #000;
      pointer-events: none;
    }

    #sanityBarContainer {
      width: 200px;
      height: 14px;
      border: 1px solid #fff;
      margin-top: 5px;
      background: rgba(0,0,0,0.5);
    }

    #sanityBar {
      width: 100%;
      height: 100%;
      background: #4caf50;
    }

    #message {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      text-shadow: 0 0 5px #000;
      opacity: 0.9;
      pointer-events: none;
      max-width: 90%;
      text-align: center;
    }

    #centerDot {
      position: fixed;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: #fff;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      opacity: 0.7;
      pointer-events: none;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<div id="ui">
  <div>WASD / Arrow keys to move</div>
  <div>Mouse to look (click screen)</div>
  <div>Sanity:</div>
  <div id="sanityBarContainer"><div id="sanityBar"></div></div>
</div>

<div id="message"></div>
<div id="centerDot"></div>

<script>
  // ==========================
  // Canvas setup
  // ==========================
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // ==========================
  // Maze generation (DFS)
  // ==========================
  const MAP_W = 31;  // must be odd
  const MAP_H = 31;  // must be odd
  const CELL_WALL = 1;
  const CELL_EMPTY = 0;

  const map = [];
  for (let y = 0; y < MAP_H; y++) {
    map[y] = [];
    for (let x = 0; x < MAP_W; x++) {
      map[y][x] = CELL_WALL;
    }
  }

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function generateMaze() {
    function carve(x, y) {
      map[y][x] = CELL_EMPTY;
      const dirs = shuffle([
        [1, 0],
        [-1, 0],
        [0, 1],
        [0, -1]
      ]);

      for (const [dx, dy] of dirs) {
        const nx = x + dx * 2;
        const ny = y + dy * 2;
        if (nx > 0 && nx < MAP_W - 1 && ny > 0 && ny < MAP_H - 1) {
          if (map[ny][nx] === CELL_WALL) {
            map[y + dy][x + dx] = CELL_EMPTY;
            carve(nx, ny);
          }
        }
      }
    }

    carve(1, 1);

    // add some random "rooms" to feel like backrooms
    for (let i = 0; i < 20; i++) {
      const rx = 2 + Math.floor(Math.random() * (MAP_W - 4));
      const ry = 2 + Math.floor(Math.random() * (MAP_H - 4));
      const rw = 2 + Math.floor(Math.random() * 4);
      const rh = 2 + Math.floor(Math.random() * 4);

      for (let y = ry; y < ry + rh && y < MAP_H - 1; y++) {
        for (let x = rx; x < rx + rw && x < MAP_W - 1; x++) {
          map[y][x] = CELL_EMPTY;
        }
      }
    }
  }

  generateMaze();

  function isWall(x, y) {
    x = Math.floor(x);
    y = Math.floor(y);
    if (x < 0 || x >= MAP_W || y < 0 || y >= MAP_H) return true;
    return map[y][x] === CELL_WALL;
  }

  // ==========================
  // Player
  // ==========================
  const player = {
    x: 2.5,
    y: 2.5,
    angle: 0,
    fov: Math.PI / 3,
    moveSpeed: 3,
    rotSpeed: 2.5
  };

  // place player somewhere empty
  for (let y = 1; y < MAP_H - 1; y++) {
    for (let x = 1; x < MAP_W - 1; x++) {
      if (map[y][x] === CELL_EMPTY) {
        player.x = x + 0.5;
        player.y = y + 0.5;
        y = MAP_H;
        break;
      }
    }
  }

  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });

  // Mouse look
  let pointerLocked = false;
  canvas.addEventListener('click', () => {
    const req = canvas.requestPointerLock || canvas.mozRequestPointerLock;
    if (req) req.call(canvas);
  });

  document.addEventListener('pointerlockchange', lockChange, false);
  document.addEventListener('mozpointerlockchange', lockChange, false);

  function lockChange() {
    pointerLocked =
      document.pointerLockElement === canvas ||
      document.mozPointerLockElement === canvas;
  }

  document.addEventListener('mousemove', e => {
    if (!pointerLocked) return;
    const sensitivity = 0.0025;
    player.angle += e.movementX * sensitivity;
  });

  // ==========================
  // Sanity and atmosphere
  // ==========================
  let time = 0;
  let sanity = 100;
  const sanityBar = document.getElementById('sanityBar');
  const messageEl = document.getElementById('message');
  let messageTimer = 0;

  const phrases = [
    "The hum of the lights is everywhere.",
    "You've walked this corridor before. Haven't you?",
    "Some walls don't look quite real.",
    "If something follows, don't slow down.",
    "Every corner feels like the last one.",
    "The maze shifts when you aren't looking.",
    "You are not supposed to be here."
  ];

  function showRandomMessage() {
    const text = phrases[Math.floor(Math.random() * phrases.length)];
    messageEl.textContent = text;
    messageTimer = 5;
  }

  function updateSanity(brightness, dt) {
    // darker -> faster drain
    const inDark = brightness < 0.7;
    const drain = inDark ? 5 : -1.5;
    sanity += drain * dt;
    if (sanity < 0) sanity = 0;
    if (sanity > 100) sanity = 100;

    sanityBar.style.width = sanity + '%';
    if (sanity > 60) sanityBar.style.background = '#4caf50';
    else if (sanity > 30) sanityBar.style.background = '#ff9800';
    else sanityBar.style.background = '#f44336';
  }

  // ==========================
  // Footstep audio (simple)
  // ==========================
  let audioCtx = null;
  let lastStepTime = 0;

  function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  window.addEventListener('click', initAudio, { once: true });

  function playFootstep() {
    if (!audioCtx) return;
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = 'triangle';
    osc.frequency.setValueAtTime(100 + Math.random() * 40, now);
    gain.gain.setValueAtTime(0.001, now);
    gain.gain.exponentialRampToValueAtTime(0.15, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);

    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + 0.2);
  }

  // ==========================
  // Raycasting render
  // ==========================
  function castRay(angle) {
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);
    let dist = 0;
    const step = 0.02;

    let hit = false;
    let wallType = 0;

    let hitX = 0;
    let hitY = 0;

    while (!hit && dist < 30) {
      dist += step;
      const x = player.x + cos * dist;
      const y = player.y + sin * dist;

      if (isWall(x, y)) {
        hit = true;
        wallType = 1;
        hitX = x;
        hitY = y;
      }
    }
    return { dist, hit, wallType, hitX, hitY };
  }

  function renderScene(dt) {
    const w = canvas.width;
    const h = canvas.height;

    ctx.clearRect(0, 0, w, h);

    // sky / ceiling
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, w, h);

    const numRays = w;
    const halfH = h / 2;

    // flicker base
    const flicker = 0.15 * Math.sin(time * 6 + Math.cos(time * 2));
    const baseLight = 0.8;
    let globalBrightness = baseLight + flicker;
    globalBrightness = Math.max(0.2, Math.min(1, globalBrightness));

    for (let x = 0; x < numRays; x++) {
      const cameraX = 2 * x / numRays - 1;
      const rayAngle = player.angle + cameraX * player.fov;

      const ray = castRay(rayAngle);
      if (!ray.hit) continue;

      // fix fish-eye
      const correctedDist = ray.dist * Math.cos(rayAngle - player.angle);
      const wallHeight = (1 / correctedDist) * h * 0.9;

      const startY = Math.floor(halfH - wallHeight / 2);
      const endY = Math.floor(halfH + wallHeight / 2);

      // shading by distance
      let shade = 1 / (1 + correctedDist * 0.3);
      shade *= globalBrightness;

      // slight yellow variations
      const noise = (Math.sin(ray.hitX * 12.9898 + ray.hitY * 78.233) * 43758.5453) % 1;
      const n = Math.abs(noise);

      const r = Math.floor(240 * shade * (0.95 + n * 0.1));
      const g = Math.floor(235 * shade * (0.9 + n * 0.2));
      const b = Math.floor(160 * shade * (0.85 + n * 0.15));

      ctx.strokeStyle = `rgb(${r},${g},${b})`;
      ctx.beginPath();
      ctx.moveTo(x, startY);
      ctx.lineTo(x, endY);
      ctx.stroke();

      // floor and ceiling fake gradient
      ctx.strokeStyle = `rgba(200,190,140,${0.12 * shade})`;
      ctx.beginPath();
      ctx.moveTo(x, endY);
      ctx.lineTo(x, h);
      ctx.stroke();
    }

    // vignette
    const gradient = ctx.createRadialGradient(
      w / 2, h / 2, 50,
      w / 2, h / 2, Math.max(w, h) / 1.1
    );
    gradient.addColorStop(0, 'rgba(0,0,0,0)');
    gradient.addColorStop(1, 'rgba(0,0,0,0.7)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);

    // sanity distortion
    if (sanity < 70) {
      const intensity = (70 - sanity) / 70;
      ctx.save();
      ctx.globalAlpha = 0.2 * intensity;
      ctx.fillStyle = '#000000';
      const lines = 8 * intensity;
      for (let i = 0; i < lines; i++) {
        const ry = Math.random() * h;
        ctx.fillRect(0, ry, w, 1);
      }
      ctx.restore();
    }

    // death screen
    if (sanity <= 0) {
      ctx.fillStyle = 'rgba(0,0,0,0.85)';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#ff4444';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '40px Arial';
      ctx.fillText("You went insane.", w / 2, h / 2 - 20);
      ctx.font = '20px Arial';
      ctx.fillText("Reload the page for a new maze.", w / 2, h / 2 + 20);
    }

    // update sanity after render using globalBrightness
    updateSanity(globalBrightness, dt);
  }

  // ==========================
  // Main loop
  // ==========================
  let lastTime = performance.now();

  function gameLoop(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    time += dt;

    update(dt);
    renderScene(dt);

    requestAnimationFrame(gameLoop);
  }

  function update(dt) {
    if (sanity <= 0) {
      // game over state
      return;
    }

    let moving = false;

    // forward / back
    let forward = 0;
    if (keys['w'] || keys['arrowup']) forward += 1;
    if (keys['s'] || keys['arrowdown']) forward -= 1;

    // strafe
    let strafe = 0;
    if (keys['a'] || keys['arrowleft']) strafe -= 1;
    if (keys['d'] || keys['arrowright']) strafe += 1;

    const moveSpeed = player.moveSpeed * dt * (0.5 + sanity / 100);

    const sin = Math.sin(player.angle);
    const cos = Math.cos(player.angle);

    let dx = 0;
    let dy = 0;

    dx += cos * forward * moveSpeed;
    dy += sin * forward * moveSpeed;

    dx += -sin * strafe * moveSpeed;
    dy += cos * strafe * moveSpeed;

    if (dx !== 0 || dy !== 0) {
      moving = true;

      const nextX = player.x + dx;
      const nextY = player.y + dy;

      // simple collision
      if (!isWall(nextX, player.y)) player.x = nextX;
      if (!isWall(player.x, nextY)) player.y = nextY;
    }

    if (moving) {
      const nowMs = performance.now();
      if (nowMs - lastStepTime > 350) {
        playFootstep();
        lastStepTime = nowMs;
      }
    }

    // random creepy text
    if (Math.random() < dt * 0.05) {
      showRandomMessage();
    }
    if (messageTimer > 0) {
      messageTimer -= dt;
      if (messageTimer <= 0) messageEl.textContent = '';
    }
  }

  requestAnimationFrame(gameLoop);
</script>
</body>
</html>