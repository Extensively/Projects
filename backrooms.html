<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Backrooms Prototype</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      color: #fff;
      overflow: hidden;
    }

    canvas {
      display: block;
      background: #000;
    }

    #ui {
      position: fixed;
      left: 10px;
      top: 10px;
      z-index: 10;
      font-size: 14px;
      text-shadow: 0 0 4px #000;
      pointer-events: none;
    }

    #sanityBarContainer {
      width: 200px;
      height: 14px;
      border: 1px solid #fff;
      margin-top: 5px;
      background: rgba(0,0,0,0.5);
    }

    #sanityBar {
      width: 100%;
      height: 100%;
      background: #4caf50;
    }

    #message {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      text-shadow: 0 0 5px #000;
      opacity: 0.8;
      pointer-events: none;
      max-width: 90%;
      text-align: center;
    }

    #centerDot {
      position: fixed;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: #fff;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      opacity: 0.6;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="ui">
    <div>WASD or Arrow Keys to move</div>
    <div>Mouse to look</div>
    <div>Sanity:</div>
    <div id="sanityBarContainer">
      <div id="sanityBar"></div>
    </div>
  </div>

  <div id="message"></div>
  <div id="centerDot"></div>

  <script>
    // ========================
    // Basic setup
    // ========================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // ========================
    // Player & camera
    // ========================
    const player = {
      x: 0,
      y: 0,
      angle: 0,
      speed: 2.2
    };

    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.key.toLowerCase()] = true;
    });
    window.addEventListener('keyup', e => {
      keys[e.key.toLowerCase()] = false;
    });

    // Mouse look
    let pointerLocked = false;
    canvas.addEventListener('click', () => {
      canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
      if (canvas.requestPointerLock) canvas.requestPointerLock();
    });

    document.addEventListener('pointerlockchange', lockChangeAlert, false);
    document.addEventListener('mozpointerlockchange', lockChangeAlert, false);

    function lockChangeAlert() {
      pointerLocked =
        document.pointerLockElement === canvas ||
        document.mozPointerLockElement === canvas;
    }

    document.addEventListener('mousemove', e => {
      if (!pointerLocked) return;
      const sensitivity = 0.003;
      player.angle += e.movementX * sensitivity;
    });

    // ========================
    // World generation (infinite tiled rooms)
    // ========================
    // We'll create a repeating grid of "rooms" with columns.
    const TILE_SIZE = 250; // size of cell in world units
    const COLS_PER_ROOM = 5;
    const ROOM_SIZE = TILE_SIZE * COLS_PER_ROOM;

    function pseudoRandom(x, y) {
      // simple deterministic pseudo random
      const seed = x * 73856093 ^ y * 19349663;
      let t = (seed << 13) ^ seed;
      return (1.0 - ((t * (t * t * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
    }

    function getTileType(tx, ty) {
      // 0 = floor, 1 = column
      // columns placed pseudo-randomly
      const r = Math.abs(pseudoRandom(tx, ty));
      if (r > 0.8) return 1;
      return 0;
    }

    // ========================
    // Lighting & atmosphere
    // ========================
    let time = 0;
    let messageTimer = 0;
    const messageEl = document.getElementById('message');

    const phrases = [
      "If you hear something behind you, don't turn around.",
      "These yellow walls go on forever.",
      "You don't remember how you got here.",
      "The hum of the lights never stops.",
      "Somewhere, an exit exists. Probably.",
      "You swear you've seen this stain before.",
      "Your footsteps echo, but the room is empty."
    ];

    function showRandomMessage() {
      const text = phrases[Math.floor(Math.random() * phrases.length)];
      messageEl.textContent = text;
      messageTimer = 5; // seconds
    }

    // ========================
    // Sanity system
    // ========================
    let sanity = 100;
    const sanityBar = document.getElementById('sanityBar');

    function updateSanity(inDark, dt) {
      const drainRate = inDark ? 4 : -1; // lose faster in dark, slowly recover in light
      sanity += drainRate * dt;
      if (sanity < 0) sanity = 0;
      if (sanity > 100) sanity = 100;

      sanityBar.style.width = sanity + '%';

      // change color based on sanity
      if (sanity > 60) {
        sanityBar.style.background = '#4caf50';
      } else if (sanity > 30) {
        sanityBar.style.background = '#ff9800';
      } else {
        sanityBar.style.background = '#f44336';
      }
    }

    // ========================
    // Footstep sounds (basic, using Web Audio)
    // ========================
    let audioCtx = null;
    let lastStepTime = 0;

    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playFootstep() {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'triangle';
      osc.frequency.setValueAtTime(80 + Math.random() * 40, now);
      gain.gain.setValueAtTime(0.001, now);
      gain.gain.exponentialRampToValueAtTime(0.1, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);

      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.25);
    }

    // Start audio on first interaction
    window.addEventListener('click', initAudio, { once: true });

    // ========================
    // Main update loop
    // ========================
    let lastTime = performance.now();

    function loop(now) {
      const dt = (now - lastTime) / 1000;
      lastTime = now;
      time += dt;

      update(dt);
      render();

      requestAnimationFrame(loop);
    }

    function update(dt) {
      // Movement
      let moving = false;
      let forward = 0;
      let strafe = 0;

      if (keys['w'] || keys['arrowup']) { forward += 1; moving = true; }
      if (keys['s'] || keys['arrowdown']) { forward -= 1; moving = true; }
      if (keys['a'] || keys['arrowleft']) { strafe -= 1; moving = true; }
      if (keys['d'] || keys['arrowright']) { strafe += 1; moving = true; }

      const len = Math.hypot(forward, strafe) || 1;
      forward /= len;
      strafe /= len;

      const moveSpeed = player.speed * (0.5 + sanity / 100); // slower when low sanity

      const dx = (Math.cos(player.angle) * forward - Math.sin(player.angle) * strafe) * moveSpeed;
      const dy = (Math.sin(player.angle) * forward + Math.cos(player.angle) * strafe) * moveSpeed;

      if (dx !== 0 || dy !== 0) {
        // collision with columns (simple)
        const nextX = player.x + dx;
        const nextY = player.y + dy;
        const tileX = Math.floor(nextX / TILE_SIZE);
        const tileY = Math.floor(nextY / TILE_SIZE);
        if (getTileType(tileX, tileY) === 0) {
          player.x = nextX;
          player.y = nextY;
        }
      }

      // Footsteps
      if (moving) {
        const nowMs = performance.now();
        if (nowMs - lastStepTime > 350) {
          playFootstep();
          lastStepTime = nowMs;
        }
      }

      // Random message occasionally
      if (Math.random() < dt * 0.03) {
        showRandomMessage();
      }

      if (messageTimer > 0) {
        messageTimer -= dt;
        if (messageTimer <= 0) messageEl.textContent = '';
      }

      // Light level based on pseudo-random flickering
      const lightLevel = 0.7 + 0.3 * Math.sin(time * 5 + Math.sin(time * 2));
      const inDark = lightLevel < 0.8;
      updateSanity(inDark, dt);
    }

    // ========================
    // Rendering (simple top‑down 2D)
    // ========================
    function render() {
      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0, 0, w, h);

      // Background
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, w, h);

      // Fake light flicker
      const flicker = 0.2 * Math.sin(time * 20 + Math.random() * 0.5);
      const baseLight = 0.75;
      let light = baseLight + flicker;
      light = Math.max(0.2, Math.min(1.0, light));

      // Camera transform (top‑down)
      ctx.save();
      ctx.translate(w / 2, h / 2);
      ctx.rotate(-player.angle);
      ctx.translate(-player.x, -player.y);

      // Draw tiling rooms around player
      const range = 4; // how many tiles around to draw
      const playerTx = Math.floor(player.x / TILE_SIZE);
      const playerTy = Math.floor(player.y / TILE_SIZE);

      for (let ty = playerTy - range; ty <= playerTy + range; ty++) {
        for (let tx = playerTx - range; tx <= playerTx + range; tx++) {
          const tileType = getTileType(tx, ty);
          const x = tx * TILE_SIZE;
          const y = ty * TILE_SIZE;

          // Floor
          if (tileType === 0) {
            const noise = Math.abs(pseudoRandom(tx * 13, ty * 7));
            const brightness = light * (0.9 + noise * 0.2);

            const r = Math.floor(230 * brightness);
            const g = Math.floor(220 * brightness);
            const b = Math.floor(170 * brightness);

            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

            // stains
            if (noise > 0.85) {
              ctx.fillStyle = `rgba(150,130,90,0.35)`;
              const sx = x + (noise * 37 % TILE_SIZE);
              const sy = y + (noise * 53 % TILE_SIZE);
              ctx.beginPath();
              ctx.ellipse(sx, sy, 20, 12, 0, 0, Math.PI * 2);
              ctx.fill();
            }

            // grid lines faint
            ctx.strokeStyle = `rgba(200,180,120,0.18)`;
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
          } else {
            // column
            const noise = Math.abs(pseudoRandom(tx * 11, ty * 5));
            const brightness = light * (0.7 + noise * 0.3);
            const r = Math.floor(210 * brightness);
            const g = Math.floor(205 * brightness);
            const b = Math.floor(160 * brightness);

            const colSize = TILE_SIZE * 0.4;
            const cx = x + TILE_SIZE / 2 - colSize / 2;
            const cy = y + TILE_SIZE / 2 - colSize / 2;
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(cx, cy, colSize, colSize);

            // shadow
            ctx.fillStyle = `rgba(0,0,0,0.4)`;
            ctx.fillRect(cx + colSize * 0.3, cy + colSize * 0.3, colSize, colSize);
          }
        }
      }

      // Player indicator (just for debugging – invisible if you want)
      // ctx.fillStyle = '#ff0000';
      // ctx.beginPath();
      // ctx.arc(player.x, player.y, 5, 0, Math.PI * 2);
      // ctx.fill();

      ctx.restore();

      // subtle vignette to feel claustrophobic
      const gradient = ctx.createRadialGradient(
        w / 2, h / 2, 50,
        w / 2, h / 2, Math.max(w, h) / 1.1
      );
      gradient.addColorStop(0, 'rgba(0,0,0,0)');
      gradient.addColorStop(1, 'rgba(0,0,0,0.7)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);

      // sanity visual distortion
      if (sanity < 60) {
        const intensity = (60 - sanity) / 60;
        ctx.save();
        ctx.globalAlpha = 0.15 * intensity;
        ctx.fillStyle = '#000000';
        for (let i = 0; i < 5 * intensity; i++) {
          const rx = Math.random() * w;
          const ry = Math.random() * h;
          const rw = 40 + Math.random() * 60;
          const rh = 2;
          ctx.fillRect(rx, ry, rw, rh);
        }
        ctx.restore();
      }

      // "You died" when sanity is 0
      if (sanity <= 0) {
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = '#ff4444';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = '40px Arial';
        ctx.fillText("You went insane.", w / 2, h / 2 - 20);
        ctx.font = '20px Arial';
        ctx.fillText("Refresh the page to try again.", w / 2, h / 2 + 20);
      }
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
