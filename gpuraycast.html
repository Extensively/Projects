<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GPU Path Tracer: Perfect Accumulation</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; color: white; }
        canvas { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; }
        
        #ui {
            position: absolute; top: 10px; right: 10px; width: 300px;
            background: rgba(20, 20, 20, 0.95); padding: 15px;
            border-radius: 8px; border: 1px solid #444;
            max-height: 90vh; overflow-y: auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .section { margin-bottom: 15px; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .section:last-child { border: none; }
        h3 { margin: 0 0 10px 0; font-size: 14px; color: #4caf50; text-transform: uppercase; letter-spacing: 1px; }
        
        label { display: flex; justify-content: space-between; font-size: 12px; color: #ccc; margin-bottom: 6px; align-items: center; }
        input[type=range] { width: 55%; cursor: pointer; }
        input[type=color] { border: none; width: 30px; height: 20px; cursor: pointer; background: none; }
        select { width: 100%; padding: 5px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; }
        
        .stat-box { background: #000; padding: 5px; text-align: center; color: #4caf50; font-family: monospace; border-radius: 4px; margin-bottom: 10px; }

        #error-log {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #500; color: #fff; padding: 20px; border: 2px solid #f00; z-index: 1000;
            white-space: pre-wrap; font-family: monospace; max-width: 80%;
        }
    </style>
</head>
<body>

<div id="error-log"></div>
<canvas id="glcanvas"></canvas>

<div id="ui">
    <div class="stat-box" id="sampleDisplay">Samples: 0</div>

    <div class="section">
        <h3>Quality</h3>
        <label>Max Samples <input type="range" id="uMaxSamples" min="10" max="10000" step="10" value="2000"></label>
        <label>Resolution <input type="range" id="uResScale" min="0.1" max="1.0" step="0.05" value="0.5"></label>
        <label>Bounces <input type="range" id="uBounces" min="1" max="8" step="1" value="4"></label>
    </div>

    <div class="section">
        <h3>Material Editor</h3>
        <div style="margin-bottom: 10px;">
            <select id="uObjSel">
                <option value="0">Blue Sphere</option>
                <option value="1">Gold Box</option>
                <option value="2">Tetrahedron</option>
                <option value="3">Floor</option>
                <option value="4">Ceiling</option>
                <option value="5">Back Wall</option>
                <option value="6">Left Wall</option>
                <option value="7">Right Wall</option>
                <option value="8">Light Source</option>
            </select>
        </div>
        <label>Color <input type="color" id="uColor"></label>
        <label>Emission <input type="range" id="uEmit" min="0" max="10" step="0.1"></label>
        <label>Roughness <input type="range" id="uRough" min="0" max="1" step="0.05"></label>
        <label>Metallic <input type="range" id="uMetal" min="0" max="1" step="0.05"></label>
    </div>

    <div style="font-size: 11px; color: #777;">
        <b>WASD</b> Move | <b>Mouse</b> Look<br>
        <b>Click</b> to capture | <b>ESC</b> to release
    </div>
</div>

<script id="vs" type="x-shader/x-vertex">#version 300 es
in vec4 position;
void main() { gl_Position = position; }
</script>

<script id="fs" type="x-shader/x-fragment">#version 300 es
precision highp float;

uniform vec2 uResolution;
uniform float uTime;
uniform vec3 uCamPos;
uniform vec3 uCamDir;
uniform vec3 uCamRight;
uniform vec3 uCamUp;
uniform int uBounces;

// --- MATERIAL ARRAYS ---
uniform vec3 uMatColors[9];
uniform vec3 uMatParams[9]; // x=Emit, y=Rough, z=Metal

out vec4 fragColor;

// --- Math & Random ---
float seed;
float rng() {
    seed += 0.1;
    return fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233)) + seed) * 43758.5453);
}

vec3 randomHemisphere(vec3 n) {
    float u = rng();
    float v = rng();
    float phi = 6.283185 * u;
    float theta = acos(1.0 - 2.0 * v);
    float x = sin(theta) * cos(phi);
    float y = sin(theta) * sin(phi);
    float z = cos(theta);
    vec3 r = vec3(x,y,z);
    return dot(r,n) < 0.0 ? -r : r;
}

// --- Intersection Functions ---
float iPlane(vec3 ro, vec3 rd, vec4 p) {
    float h = dot(rd, p.xyz);
    if(abs(h) < 1e-4) return 1e20;
    float t = -(dot(ro, p.xyz) + p.w) / h;
    return t > 1e-4 ? t : 1e20;
}

float iSphere(vec3 ro, vec3 rd, vec4 s) {
    vec3 oc = ro - s.xyz;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - s.w*s.w;
    float h = b*b - c;
    if(h < 0.0) return 1e20;
    float t = -b - sqrt(h);
    return t > 1e-4 ? t : 1e20;
}

float iBox(vec3 ro, vec3 rd, vec3 bMin, vec3 bMax, out vec3 outN) {
    vec3 invD = 1.0 / rd;
    vec3 t0 = (bMin - ro) * invD;
    vec3 t1 = (bMax - ro) * invD;
    vec3 tS = min(t0, t1);
    vec3 tL = max(t0, t1);
    float tMin = max(max(tS.x, tS.y), tS.z);
    float tMax = min(min(tL.x, tL.y), tL.z);
    if(tMax <= tMin || tMax <= 0.0) return 1e20;
    float t = tMin > 0.0 ? tMin : tMax;
    if(t < 1e-4) return 1e20;
    
    vec3 p = ro + rd * t;
    vec3 c = (bMin + bMax) * 0.5;
    vec3 d = abs(p - c) - (bMax - bMin) * 0.5;
    if(d.x > d.y && d.x > d.z) outN = vec3(sign(p.x - c.x), 0.0, 0.0);
    else if(d.y > d.z) outN = vec3(0.0, sign(p.y - c.y), 0.0);
    else outN = vec3(0.0, 0.0, sign(p.z - c.z));
    return t;
}

float iTri(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2, out vec3 outN) {
    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;
    vec3 h = cross(rd, e2);
    float a = dot(e1, h);
    if (a > -1e-5 && a < 1e-5) return 1e20;
    float f = 1.0/a;
    vec3 s = ro - v0;
    float u = f * dot(s, h);
    if (u < 0.0 || u > 1.0) return 1e20;
    vec3 q = cross(s, e1);
    float v = f * dot(rd, q);
    if (v < 0.0 || u + v > 1.0) return 1e20;
    float t = f * dot(e2, q);
    if(t > 1e-4) {
        outN = normalize(cross(e1, e2));
        if(dot(rd, outN) > 0.0) outN = -outN;
        return t;
    }
    return 1e20;
}

// --- Map Scene ---
struct Hit { float t; vec3 n; int id; };

Hit map(vec3 ro, vec3 rd) {
    Hit h; h.t = 1e20; h.id = -1;
    float t; vec3 n;

    // 0. Sphere
    t = iSphere(ro, rd, vec4(-1.0, -1.2, 0.8, 0.8));
    if(t < h.t) { h.t = t; h.n = (ro+rd*t - vec3(-1.0, -1.2, 0.8))/0.8; h.id = 0; }

    // 1. Box
    t = iBox(ro, rd, vec3(0.4, -2.0, -0.1), vec3(1.6, 0.0, 1.1), n);
    if(t < h.t) { h.t = t; h.n = n; h.id = 1; }

    // 2. Tetra
    vec3 top = vec3(-0.5, -0.5, -0.5);
    vec3 v0 = top + vec3(0, 0.8, 0);
    vec3 v1 = top + vec3(-0.7, -0.7, 0.7);
    vec3 v2 = top + vec3(0.7, -0.7, 0.7);
    vec3 v3 = top + vec3(0, -0.7, -0.7);
    t = iTri(ro, rd, v0, v1, v2, n); if(t < h.t) { h.t=t; h.n=n; h.id=2; }
    t = iTri(ro, rd, v0, v2, v3, n); if(t < h.t) { h.t=t; h.n=n; h.id=2; }
    t = iTri(ro, rd, v0, v3, v1, n); if(t < h.t) { h.t=t; h.n=n; h.id=2; }
    t = iTri(ro, rd, v1, v2, v3, n); if(t < h.t) { h.t=t; h.n=n; h.id=2; }

    // Walls
    t = iPlane(ro, rd, vec4(0,1,0, 2.0)); if(t < h.t) { h.t=t; h.n=vec3(0,1,0); h.id=3; }
    t = iPlane(ro, rd, vec4(0,-1,0, 2.0)); if(t < h.t) { h.t=t; h.n=vec3(0,-1,0); h.id=4; }
    t = iPlane(ro, rd, vec4(0,0,1, 2.0)); if(t < h.t) { h.t=t; h.n=vec3(0,0,1); h.id=5; }
    t = iPlane(ro, rd, vec4(1,0,0, 2.0)); if(t < h.t) { h.t=t; h.n=vec3(1,0,0); h.id=6; }
    t = iPlane(ro, rd, vec4(-1,0,0, 2.0)); if(t < h.t) { h.t=t; h.n=vec3(-1,0,0); h.id=7; }

    // Light
    t = iPlane(ro, rd, vec4(0,-1,0, 1.99)); 
    if(t < h.t) {
        vec3 p = ro+rd*t;
        if(abs(p.x) < 0.5 && abs(p.z) < 0.5) { h.t=t; h.n=vec3(0,-1,0); h.id=8; }
    }
    return h;
}

struct Mat { vec3 col; float emit; float rough; float metal; };

Mat getMat(int id) {
    if(id < 0 || id > 8) return Mat(vec3(1.0,0.0,1.0), 0.0, 1.0, 0.0); // Error pink
    vec3 c = uMatColors[id];
    vec3 p = uMatParams[id]; // x=Emit, y=Rough, z=Metal
    return Mat(c, p.x, p.y, p.z);
}

// --- Trace ---
vec3 trace(vec3 ro, vec3 rd) {
    vec3 col = vec3(0.0);
    vec3 th = vec3(1.0);
    
    for(int i=0; i<8; i++) {
        if(i >= uBounces) break;
        
        Hit h = map(ro, rd);
        
        if(h.id == -1) {
            vec3 sky = mix(vec3(0.05,0.05,0.1), vec3(0.0), rd.y*0.5+0.5);
            col += th * sky;
            break;
        }
        
        Mat m = getMat(h.id);
        
        col += th * m.col * m.emit;
        th *= m.col;
        
        ro = ro + rd * h.t + h.n * 0.002;
        
        vec3 diffuse = randomHemisphere(h.n);
        vec3 reflectDir = reflect(rd, h.n);
        
        bool isMetal = rng() < m.metal;
        if(isMetal) {
             rd = normalize(reflectDir + randomHemisphere(h.n) * m.rough);
        } else {
             rd = normalize(diffuse + reflectDir * (1.0 - m.rough) * 0.1);
        }
    }
    return col;
}

void main() {
    seed = uTime + gl_FragCoord.x * 12.98 + gl_FragCoord.y * 78.23;
    vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution.xy) / uResolution.y;
    vec3 rd = normalize(uCamDir * 2.0 + uCamRight * uv.x + uCamUp * uv.y);
    vec3 col = trace(uCamPos, rd);
    col = pow(col, vec3(0.4545)); // Gamma
    fragColor = vec4(col, 1.0);
}
</script>

<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl2", { preserveDrawingBuffer: true });

function showError(msg) {
    const el = document.getElementById("error-log");
    el.style.display = "block";
    el.textContent = "ERROR:\n" + msg;
}

if (!gl) showError("WebGL 2 not supported.");

function createShader(gl, type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src.trim());
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        showError(gl.getShaderInfoLog(s));
        return null;
    }
    return s;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById("vs").text));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById("fs").text));
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) showError(gl.getProgramInfoLog(program));
gl.useProgram(program);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
const posLoc = gl.getAttribLocation(program, "position");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const uLocs = {};
['uResolution','uTime','uCamPos','uCamDir','uCamRight','uCamUp','uBounces',
 'uMatColors','uMatParams'].forEach(n => uLocs[n] = gl.getUniformLocation(program, n));

// State
let camPos = [0, 0, -4.5];
let camYaw = 0, camPitch = 0;
let frameCount = 0;

const ui = {
    res: document.getElementById("uResScale"),
    maxSamples: document.getElementById("uMaxSamples"),
    bounces: document.getElementById("uBounces"),
    sel: document.getElementById("uObjSel"),
    col: document.getElementById("uColor"),
    emit: document.getElementById("uEmit"),
    rough: document.getElementById("uRough"),
    metal: document.getElementById("uMetal"),
    stats: document.getElementById("sampleDisplay")
};

// --- DATA & SYNC ---
const matData = [
    { c: "#3333e6", e:0, r:0.1, m:0 }, // 0: Sphere
    { c: "#ffcc33", e:0, r:0.2, m:1 }, // 1: Box
    { c: "#e61ae6", e:0, r:1, m:0 },   // 2: Tetra
    { c: "#cccccc", e:0, r:1, m:0 },   // 3: Floor
    { c: "#cccccc", e:0, r:1, m:0 },   // 4: Ceil
    { c: "#cccccc", e:0, r:1, m:0 },   // 5: Back
    { c: "#cc1a1a", e:0, r:1, m:0 },   // 6: Left
    { c: "#1acc1a", e:0, r:1, m:0 },   // 7: Right
    { c: "#ffffff", e:10, r:1, m:0 }   // 8: Light
];

const hexToRgb = hex => [parseInt(hex.slice(1,3),16)/255, parseInt(hex.slice(3,5),16)/255, parseInt(hex.slice(5,7),16)/255];

// 1. Uploads ALL materials to Shader
function syncMaterialsToGPU() {
    const colors = [];
    const params = [];
    
    for(let i=0; i<9; i++) {
        const d = matData[i];
        const rgb = hexToRgb(d.c);
        colors.push(...rgb);
        params.push(d.e, d.r, d.m);
    }
    
    gl.uniform3fv(uLocs.uMatColors, new Float32Array(colors));
    gl.uniform3fv(uLocs.uMatParams, new Float32Array(params));
    frameCount = 0;
}

// 2. Updates UI sliders when selecting an object
function updateUIFromData() {
    const id = ui.sel.value;
    const d = matData[id];
    ui.col.value = d.c;
    ui.emit.value = d.e;
    ui.rough.value = d.r;
    ui.metal.value = d.m;
}

// 3. Saves UI sliders into Data, then triggers Sync
function saveData() {
    const id = ui.sel.value;
    matData[id].c = ui.col.value;
    matData[id].e = parseFloat(ui.emit.value);
    matData[id].r = parseFloat(ui.rough.value);
    matData[id].m = parseFloat(ui.metal.value);
    syncMaterialsToGPU();
}

// Events
ui.sel.addEventListener("change", updateUIFromData);
[ui.col, ui.emit, ui.rough, ui.metal].forEach(el => el.addEventListener("input", saveData));
ui.bounces.addEventListener("input", () => frameCount = 0);
ui.maxSamples.addEventListener("input", () => { /* No reset needed just for changing limit */ });

function resize() {
    const scale = parseFloat(ui.res.value);
    const w = Math.floor(window.innerWidth * scale);
    const h = Math.floor(window.innerHeight * scale);
    if(canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
        gl.viewport(0, 0, w, h);
        frameCount = 0;
    }
}
ui.res.addEventListener("input", resize);
window.addEventListener("resize", resize);
resize();

// Input
const keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
canvas.addEventListener("click", () => canvas.requestPointerLock());
document.addEventListener("mousemove", e => {
    if(document.pointerLockElement === canvas) {
        camYaw += e.movementX * 0.002;
        camPitch -= e.movementY * 0.002;
        camPitch = Math.max(-1.5, Math.min(1.5, camPitch));
        frameCount = 0;
    }
});

function render() {
    // Movement
    let speed = 0.15;
    let fwd = [Math.sin(camYaw), 0, Math.cos(camYaw)];
    let right = [Math.cos(camYaw), 0, -Math.sin(camYaw)];
    let moved = false;
    
    if(keys['w']) { camPos[0]+=fwd[0]*speed; camPos[2]+=fwd[2]*speed; moved=true; }
    if(keys['s']) { camPos[0]-=fwd[0]*speed; camPos[2]-=fwd[2]*speed; moved=true; }
    if(keys['a']) { camPos[0]-=right[0]*speed; camPos[2]-=right[2]*speed; moved=true; }
    if(keys['d']) { camPos[0]+=right[0]*speed; camPos[2]+=right[2]*speed; moved=true; }
    if(keys['e']) { camPos[1]+=speed; moved=true; }
    if(keys['q']) { camPos[1]-=speed; moved=true; }
    if(moved) frameCount = 0;

    // Check Max Samples Limit
    const maxS = parseInt(ui.maxSamples.value);
    if(frameCount > maxS) {
        requestAnimationFrame(render);
        return; // Pause rendering
    }

    // --- TRUE ACCUMULATION BLENDING ---
    if(frameCount === 0) {
        gl.disable(gl.BLEND);
    } else {
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA);
    }
    
    // Uniforms
    gl.uniform2f(uLocs.uResolution, canvas.width, canvas.height);
    gl.uniform1f(uLocs.uTime, frameCount);
    gl.uniform3fv(uLocs.uCamPos, camPos);
    
    let cp = Math.cos(camPitch), sp = Math.sin(camPitch);
    let cy = Math.cos(camYaw), sy = Math.sin(camYaw);
    gl.uniform3fv(uLocs.uCamDir, [sy*cp, sp, cy*cp]);
    gl.uniform3fv(uLocs.uCamRight, [cy, 0, -sy]);
    gl.uniform3fv(uLocs.uCamUp, [sy*-sp, cp, cy*-sp]);
    gl.uniform1i(uLocs.uBounces, parseInt(ui.bounces.value));
    
    // Set Blend Alpha for True Average: 1 / (N+1)
    // Frame 0: 1/1 = 1.0 (Replace)
    // Frame 1: 1/2 = 0.5 (Average)
    // Frame 2: 1/3 = 0.33
    const alpha = 1.0 / (frameCount + 1);
    gl.blendColor(0,0,0, alpha);
    
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    
    frameCount++;
    ui.stats.innerText = `Samples: ${frameCount}`;
    requestAnimationFrame(render);
}

// Initial Sync
updateUIFromData();
syncMaterialsToGPU();
requestAnimationFrame(render);

</script>
</body>
</html>